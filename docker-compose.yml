version: '3.8'

services:
  # Serviço de Banco de Dados (PostgreSQL)
  db:
    image: postgres:14-alpine
    container_name: postgres_db # Nome do contêiner para fácil identificação
    restart: always
    environment:
      POSTGRES_DB: ${DB_DATABASE}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - pgdata:/var/lib/postgresql/data # Persiste os dados do banco de dados
    ports:
      - "${DB_EXT_PORT}:5432" # Mapeia a porta 5432 do contêiner para uma porta externa no host
    networks:
      - app_network # Conecta o serviço à rede compartilhada do Docker Compose

  # Serviço da API de Autenticação (Express.js, Porta 5000)
  auth-api:
    build:
      context: ./auth-api # Caminho para o diretório do seu Dockerfile da API de Autenticação
      dockerfile: Dockerfile
    container_name: auth_api # Nome do contêiner
    restart: always
    ports:
      - "5000:5000" # Mapeia a porta 5000 do contêiner para a porta 5000 do host
    environment:
      NODE_ENV: development
      DATABASE_URL: postgresql://postgres.fpvozizpfgohltxujgeo:cefetmg@aws-0-sa-east-1.pooler.supabase.com:6543/postgres
      JWT_SECRET: ${JWT_SECRET}
      GMAIL_USER: domain.gmail.com
      GMAIL_APP_PASSWORD: create_gmail_password
      # Adicione outras variáveis de ambiente específicas da sua API de Autenticação aqui, se houver
    networks:
      - app_network # Conecta o serviço à rede compartilhada

  # Serviço do Backend (API de Obras, NestJS, Porta 3000)
  backend:
    build:
      context: ./backend # Caminho para o diretório do seu Dockerfile do Backend
      dockerfile: Dockerfile
    container_name: backend_api # Nome do contêiner
    restart: always
    ports:
      - "3000:3000" # Mapeia a porta 3000 do contêiner para a porta 3000 do host
    environment:
      # **Ajuste CRÍTICO aqui:** Use o nome do serviço 'auth-api' como host
      NODE_ENV: ${NODE_ENV}
      DB_HOST: ${DB_HOST}
      DB_PORT: 5432
      DB_EXT_PORT: 15432
      DB_DATABASE: ${DB_DATABASE}
      DB_USER: ${DB_USER}
      DB_PASSWORD: ${DB_PASSWORD}
      TOKEN_VALIDATOR_API_URL: http://auth-api:5000/auth/validate
      DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_DATABASE} # 'db' é o nome do serviço do DB
      # JWT_SECRET: ${JWT_SECRET} # Se você usa JWT_SECRET, defina no seu arquivo .env
    depends_on:
      - db # O backend depende do banco de dados
      - auth-api # O backend depende da API de Autenticação
    volumes:
      # Volumes para desenvolvimento (hot-reloading). Remova em produção se não precisar.
      - ./backend:/app
      - /app/node_modules
    networks:
      - app_network # Conecta o serviço à rede compartilhada

  # Serviço do Frontend (Next.js, Porta 3001 no host, 3001 no contêiner)
  frontend:
    build:
      context: ./frontend # Caminho para o diretório do seu Dockerfile do Frontend
      dockerfile: Dockerfile
    container_name: frontend_app # Nome do contêiner
    restart: always
    ports:
      - "3001:3001" # Mapeia a porta 3001 do contêiner (Next.js) para a porta 3001 do host
    environment:
      # Se seu frontend precisar da URL do backend, passe-a aqui
      # Em Next.js, variáveis de ambiente prefixadas com NEXT_PUBLIC_ são expostas ao browser
      NEXT_PUBLIC_BACKEND_URL: http://localhost:3001 # O frontend acessa o backend via a porta mapeada no host
      # Ou, se você estiver acessando o backend de dentro do container Docker (ex: SSR, API Routes)
      # BACKEND_URL_INTERNAL: http://backend:3001
    depends_on:
      - backend # O frontend depende do backend
    networks:
      - app_network # Conecta o serviço à rede compartilhada

# Definição de Volumes para persistência de dados do DB
volumes:
  pgdata:

# Definição da rede compartilhada para que todos os serviços possam se comunicar
networks:
  app_network:
    driver: bridge